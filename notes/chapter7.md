# 第7章 现实应用

## 7.1 Java 8

### 7.1.3 Java 8的stream

> Java 8的stream抽象为众多高级的函数式特性奠定了基础。stream在很多方面的行为都与集合相似，但有一些关键的区别。
> - stream不存储值，只担当从输入源引出的管道角色，一直连接到终结操作上产生输出。
> - stream从设计上就偏向函数式风格，避免与状态发生关联。例如filter()操作在返回筛选结果的stream时，并不会改动底下的集合。
> - stream上的操作尽可能做到缓求值（详见第4章）。
> - stream可以没有边界（无限长）。例如我们可以构造一个返回所有数字的stream，然后用limit()、findFirst()等方法来取得其一部分子集。
> - stream像Iterator的实例一样，也是消耗品，用过之后必须重新生成新的stream才能再次操作。


## 7.2 函数式的基础设施
> 函数式的架构从根本上贯彻“值不可变”的思路，最大化地发挥其优点。学会从值不可变的角度去思考，是我们掌握函数式程序员的思维方法的一条重要门径。在函数式的思维下，我们会意识到，测试是为了确认代码中成功地制造了我们需要的变化。换言之，测试的真正目的是对可变事物的检验——可变的事物越多，就需要越多的测试来保证其正确性。

>值不可变的对象天生就是线程安全的，完全不会发生同步方面的问题。它们还绝对不会由于异常而处于不明确的、预料之外的状态。因为所有的初始化过程都发生在对象的构造期间，而Java的对象构造具有原子性，也就是说，异常只会发生在我们得到对象实例之前。Joshua Bloch称这种性质为具有原子性的失败（failure atomicity）：只要对象构造完毕，就不会再发生由值可变性引发的失败。

- 实现值不可变的Java类，需要：
  - 把所有的字段都标记为final。
  - 把类标记为final，防止被子类覆盖。
  - 不要提供无参数的构造器。
    - >一个值不可变的对象，它的一切状态都必须通过构造器来设定。假如我们没有需要设定的状态，那建立这么一个对象又有何必要呢？在无状态的类里面安排几个静态方法就足够了。
  - 提供至少一个构造器。
    - >构造器是我们在对象里添置状态的最后机会！
  - 除了构造器之外，不要提供任何制造变化的方法。
    - >必须小心防范，不能返回任何值可变的对象引用。标记了final的对象引用并不等于它所指向的一切都不可改变。
- 命令-查询职责隔离（Command-Query Responsibility Segregation，CQRS）架构
  - >立足于现有的基础设施，去追求理想的函数式境界
  - >分离架构中负责读取的部分和负责命令的部分，部分地简化了程序的架构。一部分模型（以及同样分化了功能的控制器）处理数据库的更新，另外一些模型负责数据的展示和报告。


### 7.2.2 Web框架
- 路由框架
  - 从应用的主体功能中剥离路由的相关细节，将之交托给专门的路由功能库
- 以函数作为路由的目标
- 领域专用语言（DSL）
  - >DSL定义为表达能力有限，专门针对一个狭窄问题域的计算机编程语言。其中内部DSL使用较为广泛。内部DSL是在其宿主语言之上构造出来的新“语言”，且利用宿主语言的语法糖衣来形成自身的风格。
  - 比如C#的LINQ扩展就是内部DSL
- 与构建工具紧密集成


### 7.2.3 数据库
- 为了最大化利用存储空间，关系型数据库采用破坏性更新（新值替代旧值）
  - 基于当时设计时内存很贵，存储很贵，网速很慢
- 现在内存，存储便宜，网速很快。函数式架构下的数据库，比如Datomic，采取值不可变，计入时间戳的想法。因为值不可变，所以使函数式概念得以浸染，并且当值更新了，只需要更改引用即可。
  - Datomic设计产生的结果：
    - 永久地记录所有的schema变更和数据变更。所以数据库可以轻易地回退到旧的版本
    - 读取和写入分离。不会因为查询推迟更新。架构上相当于拥有一个CQRS系统
    - 事件驱动型架构中的值不可变性和时间戳。满足回退和重放事件