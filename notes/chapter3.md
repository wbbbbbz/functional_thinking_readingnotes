# 第三章

> 软件开发的进步过程就是这样。我们构造一层又一层的抽象来处理（并隐藏）琐碎的细节。随着硬件能力的提高，我们将越来越多的任务转嫁给语言和运行时。

> 抽象的目的总是一样的：让开发者从繁琐的运作细节里解脱出来，去解答问题中非重复性的那些方面。

## 3.1 迭代让位于高阶函数

> 理解掌握的抽象层次永远要比日常使用的抽象层次更深一层

> 程序员的工作效率依赖于抽象层，好比没有人会直接翻弄硬盘上或0或1的磁记录来给计算机编程。抽象隐藏了繁杂的细节，只是有时候会连同重要的考虑因素一起隐藏掉。

## 3.2 闭包

> 闭包（closure）是所有函数式语言都具备的一项平常特性，可是相关的论述却常常充斥着晦涩乃至神秘的字眼。所谓闭包，实际上是一种特殊的函数，它在暗地里绑定了函数内部引用的所有变量。换句话说，这种函数（或方法）把它引用的所有东西都放在一个上下文里“包”了起来

> 闭包在生成的时候，会把引用的变量全部圈到代码块的作用域里，封闭、包围起来（故名闭包）。闭包的每个实例都保有自己的一份变量取值，包括私有变量也是如此。

> “闭包”这个名字来源于它创建封闭上下文的行为。虽然局部变量不是在代码块里面定义的，但只要代码块引用了该变量，两者就被绑定在一起，这种联系在代码块实例的全部生命期内都一直保持着。从实现的角度来说，代码块实例从它被创建的一刻起，就持有其作用域内一切事物的封闭副本。当代码块实例被垃圾收集的时候，它持有的引用也同时被回收。

- 闭包常见的用法是**绑定常量或者不可变的值**

- 闭包蕴含的一个函数式编程思维就是“让Runtime去管理状态”。省去在类中保存字段，并且维护状态（甚至在多线程状态下）。

> 闭包还是**推迟执行**原则的绝佳样板。我们把代码绑定到闭包之后，可以推迟到适当的时机再执行闭包。这个特点在很多场合都能发挥作用。例如必要的变量和函数可能并不在定义时的作用域里，要到执行的时候才准备好。那么我们把执行上下文放在闭包里保留起来，就可以等到正确的时机再完成执行。

## 3.3 柯里化和函数的部分施用

> 柯里化指的是从一个多参数函数变成一连串单参数函数的变换。它描述的是变换的过程，不涉及变换之后对函数的调用。调用者可以决定对多少个参数实施变换，余下的部分将衍生为一个参数数目较少的新函数。

- 函数process(x, y, z)完全柯里化 => process(x)(y)(z)

> 部分施用指通过提前代入一部分参数值，使一个多参数函数得以省略部分参数，从而转化为一个参数数目较少的函数。这种技法叫作“部分施用”，顾名思义，就是让函数先作用于其中一些参数，经过部分的求解，结果返回一个由余下参数构成签名的函数。

- 函数process(x, y, z)部分施用 => process(y, z)

### 3.3.4 Scala的情况

Scala支持柯里化和部分施用，另外还有一个用来定义偏函数的trait
- 偏函数: PartialFunction。经常使用的一个实例就是case语句，模式匹配
  ```scala
  val pf:PartialFunction[Int,String] = {
    case1=>"一"
    case2=>"二"
    case3=>"三"
    case_=>"其他"
    }
  ```
  - 参考：[Scala学习笔记(六) Scala的偏函数和偏应用函数 - 简书](https://www.jianshu.com/p/0a8a15dbb348)
  - collect()在设计的时候就考虑到传入偏函数的情况，会调用isDefinedAt()函数来鉴别集合元素是否符合取值条件，不符合的就被忽略掉了。map()遇到不符合的会报错


### 3.3.5 一般用途

- 函数工厂
  - 工厂方法的场合，正适合柯里化（以及部分施用）表现它的才干
  - 通过柯里化或者部分施用，从一个抽象的函数中制造出其他函数

- Template Method模式
  - 部分施用技法注入当前已经确定的行为，留下未确定的参数给具体实现去发挥，其思路与模板方法这种面向对象的设计模式如出一辙。

- 隐含参数
  - 使用部分施用，省去反复写相同参数值（比如this）的问题


## 3.4 递归

- 对于诸多函数式语言来说，列表并不是带有索引的形式，而是由列表的第一个元素（叫作头部）和列表的其余元素（叫作尾部）这两部分组合而成。
  - 这种结构更有利于递归

- 命令式编程中，程序员管理状态，返回值。递归写法是将管理状态的任务交给了Runtime（调用栈）

## 3.5 Stream和作业顺序重排
> 从命令式风格转变为函数式风格还有一个潜在的好处，那就是运行时有能力在涉及效率的问题上替我们做决定。
```java
public String cleanNames(List<String> names) {
    if (names == null) return "";
    return names
         .stream()
         .map(e -> capitalize(e))
         .filter(n -> n.length() > 1)
         .collect(Collectors.joining(","));
}
```
- 比如上述例子。命令式思路的话应该将筛选放在映射操作的前面，这样map的工作量会减少。但是很多函数式语言在下游的终结操作(比如collect)之前都是lazy操作，不会产生结果。这样Runtime就可以优化lazy操作的执行顺序。当然前提是必须保证每一个操作没有副作用。
