# 第5章 演化的语言

> 函数式编程语言和面向对象语言对待代码重用的方式不一样。面向对象语言喜欢大量地建立有很多操作的各种数据结构，函数式语言也有很多的操作，但对应的数据结构却很少。面向对象语言鼓励我们建立专门针对某个类的方法，我们从类的关系中发现重复出现的模式并加以重用。函数式语言的重用表现在函数的通用性上，它们鼓励在数据结构上使用各种共通的变换，并通过高阶函数来调整操作以满足具体事项的要求。

## 5.2 让语言去迎合问题
- 揉捏语言迎合问题
- Scala从设计之初就为充当内部DSL的宿主做好了准备。

## 5.3 对分发机制的再思考
- Scala的模式匹配特性，就是一种分发机制，我们用“分发机制”这个词来泛称各种语言中用作“动态地选择行为”的特性。

## 5.4 运算符重载
- 运算符重载是函数式语言常见的特性，它允许我们重新定义运算符（诸如+、-、*），使之适用于新的类型，并承载新的行为。
- scala中，直接def +, -, *之类即可

## 5.5 函数式的数据结构
- 很多函数式语言根本就没有Java那样的“异常”概念，它们肯定有别的什么方式可以表达错误状况下的行为。
> “异常”违背了大多数函数式语言所遵循的一些前提条件。首先，函数式语言偏好没有副作用的纯函数。抛出异常的行为本身就是一种副作用，会导致程序路径偏离正轨（进入异常的流程）。函数式语言以操作值为其根本，因此喜欢在返回值里表明错误并作出响应，这样就不需要打断程序的一般流程了。

> **引用的透明性**（referential transparency）是函数式语言重视的另一项性质：发出调用的例程不必关心它的访问对象真的是一个值，还是一个返回值的函数。可是如果函数有可能抛出异常的话，用它来代替值就不再是安全的了。

### 5.5.2 Either类
> 函数式语言也经常会遇到返回两种截然不同的值的需求，它们用来建模这种行为的常用数据结构是Either类。Either的设计规定了它要么持有“左值”，要么持有“右值”，但绝不会同时持有两者。这种数据结构也被称为**不相交联合体**（disjoint union）。C语言和一些衍生语言中有一种联合体（union）数据类型，能够在同一个位置上容纳不同类型的单个实例。

- java可以利用泛型制作一个简单的Either类实现
- 使用Either，就可以在保证类安全的前提下视状况返回异常或者有效结果（但不会同时返回两个）。一般异常放左值，正常放右值。
- 使用Either可以提供默认值（比如默认的最大，最小值）

### 5.5.3 Option类
> Option类表述了异常处理中较为简化的一种场景，它的取值要么是none，表示不存在有效值，要么是some，表示成功返回。Option的取值为none()或some()其中之一，类似于Either的左值和右值，只不过专为表达“方法不一定返回有效结果”的意思而缩窄了定义。Option类可以近似地看作Either类的一个子集；Option一般只用来表示成功和失败两种情况，而Either可以容纳任意的内容。

### 5.5.4 Either树和模式匹配
- Scala的模式匹配可以和case类联用。省去case语句中的条件判断，直接转移到case类的定义里。
  ```scala
  class Color(val red:Int, val green:Int, val blue:Int)
  case class Red(r:Int) extends Color(r, 0, 0)
  case class Green(g:Int) extends Color(0, g, 0)
  case class Blue(b:Int) extends Color(0, 0, b)
  ```
  - 语法糖如下：
    1. 类名可以直接用作一个工厂方法。我们不必动用new关键字就可以构造一个新实例，如val bob = Person("Bob", 42)。
    2. 经类参数列表传入的所有值都会自动被赋予val类型，也就是说它们都成了类中值不可变的内部字段。
    3. 编译器自动为case类生成合理的equals()、hashCode()和toString()默认实现。
    4. 编译器添加到类中的copy()方法可以通过返回新副本的形式，实现对原实例的字段修改。

