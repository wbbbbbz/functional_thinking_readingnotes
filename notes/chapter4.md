# 第4章 用巧不用蛮

> 很多函数式编程构造的目的只有一个：从频繁出现的场景中消灭掉烦人的实现细节。

## 4.1 记忆
> “memoization”这个词是英国的人工智能研究者Donald Michie生造出来的，指的是在函数级别上对需要多次使用的值进行缓存的机制。

> 这种缓存函数计算结果的做法，是计算机科学里一种典型的折衷方案：用更多的内存（我们一般不缺内存）去换取长期来说更高的效率。

> 只有纯（pure）函数才可以适用缓存技术。纯函数是没有副作用的函数：它不引用其他值可变的类字段，除返回值之外不设置其他的变量，其结果完全由输入参数决定。java.lang.Math类里面的方法都是纯函数的绝好例子。很显然，只有在函数对同样一组参数总是返回相同结果的前提下，我们才可以放心地使用缓存起来的结果

### 4.1.1 缓存

> 缓存效果好，但也会付出了代价。类中的缓存就代表类有了状态，所有与缓存打交道的方法都不可以是静态的，于是产生了更多的连锁效应。我们可以安排Singleton模式来解决一部分影响，但这样做本身就提高了复杂性，还会带来一箩筐的测试问题。由于是我们自己来操控缓存，那就有责任保障其正确性（比如做一些单元测试）。缓存可以提高性能，但缓存有代价：它提高了代码的非本质复杂性和维护负担。

- 缓存除了代码的正确性，执行环境也需要考虑。比如缓存的量会不会溢出等等。状态必须精心维护

### 4.1.2 引入“记忆”
- 很多现代语言支持记忆特性，不需要记录状态，直接调用提供的记忆方法即可。
  - 命令式编程在控制缓存的时候十分复杂。直接利用提供的记忆方法，可以指定缓存的大小等等，减轻维护成本。
- 开发者的优化很难比语言设计者的优化更高效，因为语言设计者可以触碰底层设施。所以将缓存等问题交给语言，这样效率更高，也能在更高的抽象层次上思考问题

- Scala中没有直接提供记忆机制，但是可以使用getOrElseUpdate()和维护map来进行memiozation。
  ```scala
  def memoize[A, B](f: A => B) = new (A => B) {
    val cache = scala.collection.mutable.Map[A, B]()
    def apply(x: A): B = cache.getOrElseUpdate(x, f(x))
  }
  def nameHash = memoize(hash)
  ```

- 使用记忆技巧时保证函数：
  - 没有副作用
  - 不依赖外部信息
  - 值不可变